amends "package://pkg.pkl-lang.org/github.com/alphagov/pkl-concourse-pipeline/pkl-concourse-pipeline@0.0.4#/Pipeline.pkl"
import "package://pkg.pkl-lang.org/github.com/alphagov/pkl-concourse-pipeline/pkl-concourse-pipeline@0.0.4#/TaskConfig.pkl"

import "../common/pipeline_self_update.pkl"
import "../common/shared_resources.pkl"
import "../common/shared_resources_for_multi_arch_builds.pkl"
import "../common/shared_resources_for_test_pipelines.pkl" as shared_test
import "../common/shared_resources_for_slack_notifications.pkl"
import "../common/PayResources.pkl"

local class ImageToCopyFromDockerhubToECR {
  name: String
  repo: String
  tag: String
  image: String = "\(repo):\(tag)"
}

local images_to_copy_from_dockerhub_to_ecr = new Listing<ImageToCopyFromDockerhubToECR> {
  new { name = "postgres-15-alpine" repo = "postgres" tag = "15-alpine" }
  new { name = "localstack-localstack-3" repo = "localstack/localstack" tag = "3" }
  new { name = "selenium-standalone-chrome-3-141-59" repo = "selenium/standalone-chrome" tag = "3.141.59" }
}

local class ImageToMultiArchBuild {
  name: String
  github_repo: String
  dockerhub_repo: String = "governmentdigitalservice/pay-\(name)"
  ecr_repo: String = "govukpay/\(name)"
  release_tag_prefix: String  = ""
  branch: String = "master"
  copy_release_to_deploy: Boolean = false
}

local images_to_multi_arch_build = new Listing<ImageToMultiArchBuild> {
  new { name = "reverse-proxy" github_repo = "pay-scripts" release_tag_prefix = "reverse_proxy_" }
  new { name = "stubs" github_repo = "pay-stubs" copy_release_to_deploy = true }
  new { name = "zap" github_repo = "pay-scripts" release_tag_prefix = "zap_"}
}

local typealias SlackNotificationConfig = shared_resources_for_slack_notifications.SlackNotificationConfig

resources = new {
  pipeline_self_update.PayPipelineSelfUpdateResource("pay-dev/e2e-helpers.pkl", "master")
  shared_resources.payCiGitHubResource

  new PayResources.PayGitHubResource {
    name = "endtoend-git-release"
    repoName = "pay-endtoend"
    source {
      branch = "master"
      tag_regex = "alpha_release-(.*)"
    }
  }

  for (image_to_build in images_to_multi_arch_build) {
    new PayResources.PayGitHubResource {
      name = "\(image_to_build.name)-git-release"
      repoName = image_to_build.github_repo
      source {
        branch = image_to_build.branch
        tag_regex = "\(image_to_build.release_tag_prefix)alpha_release-(.*)"
      }
    }
  }

  shared_resources.payECRResource(
    "endtoend-ecr-registry-test", "govukpay/endtoend", "pay_aws_test_account_id"
  ) |> withTag("latest")

  shared_resources.payECRResourceWithVariant(
    "endtoend-candidate-ecr-registry-test", "govukpay/endtoend", "pay_aws_test_account_id", "candidate"
  )

  shared_resources.payDockerHubResource(
    "endtoend-dockerhub", "governmentdigitalservice/pay-endtoend", "latest-master"
  )

  for (image_to_build in images_to_multi_arch_build) {
    shared_resources.payECRResourceWithVariant(
      "\(image_to_build.name)-candidate-ecr-registry-test",
      "govukpay/\(image_to_build.name)",
      "pay_aws_test_account_id",
      "candidate"
    )
  }

  for (image_to_copy in images_to_copy_from_dockerhub_to_ecr) {
    shared_resources.payDockerHubResource(image_to_copy.name, image_to_copy.repo, image_to_copy.tag)
    |> withCheckInterval("1h")

    shared_resources.payECRResource("ecr-\(image_to_copy.name)", image_to_copy.repo, "pay_aws_test_account_id")
    |> withTag(image_to_copy.tag) |> withCheckInterval("never")
  }

  shared_resources.slackNotificationResource
}

groups {
  new {
    name = "copy-from-dockerhub-to-ecr"
    jobs {
      for (image in images_to_copy_from_dockerhub_to_ecr) {
        "copy-\(image.name)"
      }
    }
  }
  new {
    name = "end-to-end"
    jobs {
      "build-and-push-endtoend-candidate"
      "endtoend-e2e"
    }
  }
  for (image in images_to_multi_arch_build) {
    new {
      name = image.name
      jobs {
        "build-and-push-\(image.name)-candidate"
        "\(image.name)-e2e"
      }
    }
  }
  pipeline_self_update.payPipelineSelfUpdateGroup
}

resource_types = new {
  shared_resources.slackNotificationResourceType
}

jobs = new {
  pipeline_self_update.PayPipelineSelfUpdateJob("pay-dev/e2e-helpers.pkl")

  new {
    name = "build-and-push-endtoend-candidate"
    plan {
      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_test.getStep("endtoend-git-release", true, false)
          shared_test.getPayCi
        }
      }

      shared_resources.generateDockerCredsConfigStep
      parseReleaseTag("endtoend-git-release")
      shared_test.loadVar("release_number_tag", "tags/release-number")
      buildImage("build-endtoend-image", "endtoend-git-release")
      putCandidateImage("endtoend-candidate-ecr-registry-test")
    }

    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "Failed to build and push pay-endtoend candidate image"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "Built and pushed pay-endtoend candidate image" }
    )
  }

  new {
    name = "endtoend-e2e"
    plan {
      new InParallelStep {
        in_parallel = new Listing {
          new GetStep {
            get = "endtoend-candidate-ecr-registry-test"
            trigger = true
            passed = new Listing { "build-and-push-endtoend-candidate" }
            params { ["format"] = "oci" }
          }
          shared_test.getPayCi
        }
      }

      parseCandidateTag("endtoend-candidate-ecr-registry-test")
      shared_test.loadVar("candidate_number_tag", "parse-candidate-tag/release-number")
      shared_test.assumeCodeBuildRole("executor", "e2e-test-assume-role")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.loadVar("candidate-image-tag", "endtoend-candidate-ecr-registry-test/tag")
          shared_test.loadAssumeRoleVar
        }
      }

      shared_test.prepareCodeBuild("endtoend", "prepare-e2e-codebuild.yml", "((.:candidate-image-tag))")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.runCodeBuild("run-codebuild-card", "card.json", 3)
          shared_test.runCodeBuild("run-codebuild-products", "products.json", 1)
          shared_test.runCodeBuild("run-codebuild-zap", "zap.json", 1)
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          putStep(
            "endtoend-ecr-registry-test",
            "endtoend-candidate-ecr-registry-test/image.tar",
            "parse-candidate-tag/release-tag",
            true
          )
          putStep(
            "endtoend-dockerhub",
            "endtoend-candidate-ecr-registry-test/image.tar",
            "",
            true
          )
        }
      }
    }
    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "pay-endtoend failed post-merge e2e tests"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "pay-endtoend passed post-merge e2e tests and was pushed as a final release" }
    )
  }

  for (image in images_to_multi_arch_build) {
    multiArchBuild(image)
    multiArchEndToEndTest(image)
  }

  for (image_to_copy in images_to_copy_from_dockerhub_to_ecr) {
    copyImageToEcr(image_to_copy.name, image_to_copy.image)
  }
}

// THINGS BELOW HERE MAY BE USEFUL IN SHARED_RESOURCES

local function buildImage(taskName: String, context: String): TaskStep = new {
  task = taskName
  privileged = true
  params {
    ["CONTEXT"] = context
    ["DOCKER_CONFIG"] = "docker_creds"
  }
  config {
    platform = "linux"
    image_resource {
      type = "registry-image"
      source { ["repository"] = "concourse/oci-build-task" }
    }
    inputs = new Listing {
      new TaskConfig.Input { name = context }
      new TaskConfig.Input { name = "docker_creds" }
    }
    outputs = new Listing {
      new TaskConfig.Output { name = "image" }
    }
    run { path = "build" }
  }
}

local function putCandidateImage(putName: String): PutStep =
  putStep(putName, "image/image.tar", "tags/candidate-tag", true)

local assumeRetagRole: TaskStep = new {
  task = "assume-retag-role"
  file = "pay-ci/ci/tasks/assume-role.yml"
  output_mapping = new {
    ["assume-role"] = "assume-retag-role"
  }
  params = new {
    ["AWS_ROLE_ARN"] = "arn:aws:iam::((pay_aws_test_account_id)):role/concourse"
    ["AWS_ROLE_SESSION_NAME"] = "retag-ecr-image-as-release"
  }
}

local assumeWriteToDeployRole: TaskStep = new {
  task = "assume-write-to-deploy-role"
  file = "pay-ci/ci/tasks/assume-role.yml"
  output_mapping = new {
    ["assume-role"] = "assume-write-to-deploy-role"
  }
  params = new {
    ["AWS_ROLE_ARN"] = "arn:aws:iam::((pay_aws_deploy_account_id)):role/concourse_dev_worker_ecr_access"
    ["AWS_ROLE_SESSION_NAME"] = "write-ecr-to-deploy"
  }
}

local function copyMultiarchImageToAccount(repo: String): TaskStep = new {
  task = "copy-images-to-\(repo)-ecr-registry-deploy"
  file = "pay-ci/ci/tasks/copy-multiarch-image-to-other-account.yml"
  privileged = true
  params = new {
    ["DESTINATION_AWS_ACCESS_KEY_ID"] = "((.:write-to-deploy-role.AWS_ACCESS_KEY_ID))"
    ["DESTINATION_AWS_SECRET_ACCESS_KEY"] = "((.:write-to-deploy-role.AWS_SECRET_ACCESS_KEY))"
    ["DESTINATION_AWS_SESSION_TOKEN"] = "((.:write-to-deploy-role.AWS_SESSION_TOKEN))"
    ["DESTINATION_ECR_REGISTRY"] = "((pay_aws_deploy_account_id)).dkr.ecr.eu-west-1.amazonaws.com"
    ["ECR_REPO_NAME"] = "govukpay/\(repo)"
    ["RELEASE_NUMBER"] = "((.:release_number))"
    ["SOURCE_AWS_ACCESS_KEY_ID"] = "((.:retag-role.AWS_ACCESS_KEY_ID))"
    ["SOURCE_AWS_SECRET_ACCESS_KEY"] = "((.:retag-role.AWS_SECRET_ACCESS_KEY))"
    ["SOURCE_AWS_SESSION_TOKEN"] = "((.:retag-role.AWS_SESSION_TOKEN))"
    ["SOURCE_ECR_REGISTRY"] = "((pay_aws_test_account_id)).dkr.ecr.eu-west-1.amazonaws.com"
  }
}

local function multiArchBuild(image: ImageToMultiArchBuild): Job = new {
  name = "build-and-push-\(image.name)-candidate"
  plan {
    new InParallelStep {
      in_parallel = new Listing<Step> {
        shared_test.getPayCi
        shared_test.getStep("\(image.name)-git-release", true, false)
      }
    }

    new InParallelStep {
      in_parallel = new Listing<Step> {
        parseReleaseTag("\(image.name)-git-release")
        shared_test.assumeCodeBuildRole("builder", "codebuild-assume-role")
        shared_resources.generateDockerCredsConfigStep
      }
    }

    new InParallelStep {
      in_parallel = new Listing<Step> {
        shared_test.loadVar("release-number", "tags/release-number")
        shared_test.loadVar("release-name", "\(image.name)-git-release/.git/ref")
        shared_test.loadVar("release-sha", "tags/release-sha")
        shared_test.loadVar("candidate-image-tag", "tags/candidate-tag")
        shared_test.loadVar("date", "tags/date")
        shared_test.loadAssumeRoleVar
      }
    }

    ...shared_resources_for_multi_arch_builds.multiArchCandidateBuild(image.name)
  }
  on_failure = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { message = "Failed to build and push e2e helper \(image.name)"
      slack_channel_for_failure = "#govuk-pay-starling" }
  )
  on_success = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { is_a_success = true; message = "Built and pushed e2e helper \(image.name)" }
  )
}

local function multiArchEndToEndTest(image: ImageToMultiArchBuild): Job = new {
  name = "\(image.name)-e2e"
  plan {
    new InParallelStep {
      in_parallel = new Listing {
        shared_test.getStep("\(image.name)-candidate-ecr-registry-test", true, true)
        shared_test.getPayCi
      }
    }

    new InParallelStep {
      in_parallel = new Listing {
        shared_resources.generateDockerCredsConfigStep
        parseCandidateTag("\(image.name)-candidate-ecr-registry-test")
        shared_test.assumeCodeBuildRole("executor", "e2e-test-assume-role")
        assumeRetagRole
        when (image.copy_release_to_deploy) {
          assumeWriteToDeployRole
        }
      }
    }

    new InParallelStep {
      in_parallel = new Listing {
        shared_test.loadVar("candidate-image-tag", "\(image.name)-candidate-ecr-registry-test/tag")
        shared_test.loadAssumeRoleVar
        shared_test.loadVarJson("retag-role", "assume-retag-role/assume-role.json")
        shared_test.loadVar("release_image_tag", "parse-candidate-tag/release-tag")
        shared_test.loadVar("release_number", "parse-candidate-tag/release-number")
        when (image.copy_release_to_deploy) {
          shared_test.loadVarJson("write-to-deploy-role", "assume-write-to-deploy-role/assume-role.json")
        }
      }
    }

    shared_test.prepareCodeBuild(image.name, "prepare-e2e-codebuild.yml", "((.:candidate-image-tag))")

    new InParallelStep {
      in_parallel = new Listing {
        shared_test.runCodeBuild("run-codebuild-card", "card.json", 3)
        shared_test.runCodeBuild("run-codebuild-products", "products.json", 1)
        shared_test.runCodeBuild("run-codebuild-zap", "zap.json", 1)
      }
    }

    new InParallelStep {
      in_parallel = new Listing {
        new shared_resources_for_multi_arch_builds.RetagMultiArchImageInECR { repo = image.ecr_repo newTag = "((.:release_image_tag))" }
        new shared_resources_for_multi_arch_builds.RetagMultiArchImageInECR { repo = image.ecr_repo newTag = "latest" }
        new shared_resources_for_multi_arch_builds.RetagMultiArchImageInDockerhubAsLatestMaster { repo = image.dockerhub_repo }
        when (image.copy_release_to_deploy) {
          copyMultiarchImageToAccount(image.name)
        }
      }
    }
  }
  on_failure = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { message = "e2e helper \(image.name) failed post-merge e2e tests"
      slack_channel_for_failure = "#govuk-pay-starling" }
  )
  on_success = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { is_a_success = true; message = "e2e helper \(image.name) passed post-merge e2e tests and was pushed as a final release" }
  )
}

local function copyImageToEcr(image: String, displayName: String): Job = new {
  name = "copy-\(image)"
  plan {
    shared_test.getStep(image, true, true)
    putStep("ecr-\(image)", "\(image)/image.tar", "", true)
  }
  on_failure = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { message = "Failed copying \(displayName) image from Docker Hub to ECR"
      slack_channel_for_failure = "#govuk-pay-starling" }
  )
  on_success = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { is_a_success = true; message = "Copied \(displayName) image from Docker Hub to ECR" }
  )
}

local function parseReleaseTag(gitRelease: String): TaskStep = new {
  task = "parse-release-tag"
  file = "pay-ci/ci/tasks/parse-release-tag.yml"
  input_mapping {
    ["git-release"] = gitRelease
  }
}

local function parseCandidateTag(ecrRepo: String): TaskStep = new {
  task = "parse-candidate-tag"
  file = "pay-ci/ci/tasks/parse-candidate-tag.yml"
  input_mapping {
    ["ecr-repo"] = ecrRepo
  }
}

local function withTag(tag: String) = new Mixin {
  source { ["tag"] = tag }
}

local function withCheckInterval(interval: String) = new Mixin {
  check_every = interval
}

local function putStep(resourceName: String, imageName: String, additionalTags: String, skipDownload: Boolean): PutStep = new PutStep {
  put = resourceName
  params {
    when (imageName.length > 0) {
      ["image"] = imageName
    }
    when (additionalTags.length > 0) {
      ["additional_tags"] = additionalTags
    }
  }
  get_params {
    when (skipDownload) {
      ["skip_download"] = true
    }
  }
}
