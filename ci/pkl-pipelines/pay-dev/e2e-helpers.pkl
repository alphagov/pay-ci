amends "package://pkg.pkl-lang.org/github.com/alphagov/pkl-concourse-pipeline/pkl-concourse-pipeline@0.0.4#/Pipeline.pkl"
import "package://pkg.pkl-lang.org/github.com/alphagov/pkl-concourse-pipeline/pkl-concourse-pipeline@0.0.4#/TaskConfig.pkl"

import "../common/pipeline_self_update.pkl"
import "../common/shared_resources.pkl"
import "../common/shared_resources_for_multi_arch_builds.pkl"
import "../common/shared_resources_for_test_pipelines.pkl" as shared_test
import "../common/shared_resources_for_slack_notifications.pkl"
import "../common/PayResources.pkl"

local typealias SlackNotificationConfig = shared_resources_for_slack_notifications.SlackNotificationConfig

resources = new {
  pipeline_self_update.PayPipelineSelfUpdateResource("pay-dev/e2e-helpers.pkl", "master")
  shared_resources.payCiGitHubResource

  new PayResources.PayGitHubResource {
    name = "endtoend-git-release"
    repoName = "pay-endtoend"
    source {
      branch = "master"
      tag_regex = "alpha_release-(.*)"
    }
  }
  new PayResources.PayGitHubResource {
    name = "stubs-git-release"
    repoName = "pay-stubs"
    source {
      branch = "master"
      tag_regex = "alpha_release-(.*)"
    }
  }
  new PayResources.PayGitHubResource {
    name = "reverse-proxy-git-release"
    repoName = "pay-scripts"
    source {
      branch = "master"
      tag_regex = "reverse_proxy_alpha_release-(.*)"
    }
  }

  shared_resources.payECRResource(
    "endtoend-ecr-registry-test", "govukpay/endtoend", "pay_aws_test_account_id"
  ) |> withTag("latest")

  shared_resources.payECRResourceWithVariant(
    "endtoend-candidate-ecr-registry-test", "govukpay/endtoend", "pay_aws_test_account_id", "candidate"
  )

  shared_resources.payECRResourceWithVariant(
    "reverse-proxy-candidate-ecr-registry-test",
    "govukpay/reverse-proxy",
    "pay_aws_test_account_id",
    "candidate")

  shared_resources.payECRResourceWithVariant(
    "stubs-candidate-ecr-registry-test",
    "govukpay/stubs",
    "pay_aws_test_account_id",
    "candidate")

  shared_resources.payDockerHubResource(
    "endtoend-dockerhub", "governmentdigitalservice/pay-endtoend", "latest-master"
  )

  shared_resources.payDockerHubResource("postgres-15-alpine", "postgres", "15-alpine")
  |> withCheckInterval("1h")

  shared_resources.payECRResource("ecr-postgres-15-alpine", "postgres", "pay_aws_test_account_id")
  |> withTag("15-alpine") |> withCheckInterval("never")

  shared_resources.payDockerHubResource("localstack-localstack-3", "localstack/localstack", "3")
  |> withCheckInterval("1h")

  shared_resources.payECRResource(
    "ecr-localstack-localstack-3", "localstack/localstack", "pay_aws_test_account_id"
  ) |> withTag("3") |> withCheckInterval("never")

  shared_resources.payDockerHubResource(
    "selenium-standalone-chrome-3-141-59", "selenium/standalone-chrome", "3.141.59"
  ) |> withCheckInterval("1h")

  shared_resources.payECRResource(
    "ecr-selenium-standalone-chrome-3-141-59", "selenium/standalone-chrome", "pay_aws_test_account_id"
  ) |> withTag("3.141.59") |> withCheckInterval("never")

  shared_resources.slackNotificationResource
}

resource_types = new {
  shared_resources.slackNotificationResourceType
}

jobs = new {
  pipeline_self_update.PayPipelineSelfUpdateJob("pay-dev/e2e-helpers.pkl")

  new {
    name = "build-and-push-endtoend-candidate"
    plan {
      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_test.getStep("endtoend-git-release", true, false)
          shared_test.getPayCi
        }
      }

      shared_resources.generateDockerCredsConfigStep
      parseReleaseTag("endtoend-git-release")
      shared_test.loadVar("release_number_tag", "tags/release-number")
      buildImage("build-endtoend-image", "endtoend-git-release")
      putCandidateImage("endtoend-candidate-ecr-registry-test")
    }

    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "Failed to build and push pay-endtoend candidate image"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "Built and pushed pay-endtoend candidate image" }
    )
  }

  new {
    name = "endtoend-e2e"
    plan {
      new InParallelStep {
        in_parallel = new Listing {
          new GetStep {
            get = "endtoend-candidate-ecr-registry-test"
            trigger = true
            passed = new Listing { "build-and-push-endtoend-candidate" }
            params { ["format"] = "oci" }
          }
          shared_test.getPayCi
        }
      }

      parseCandidateTag("endtoend-candidate-ecr-registry-test")
      shared_test.loadVar("candidate_number_tag", "parse-candidate-tag/release-number")
      shared_test.assumeCodeBuildRole("executor", "e2e-test-assume-role")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.loadVar("candidate_image_tag", "endtoend-candidate-ecr-registry-test/tag")
          shared_test.loadAssumeRoleVar
        }
      }

      shared_test.prepareCodeBuild("endtoend", "prepare-e2e-codebuild.yml", "((.:candidate_image_tag))")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.runCodeBuild("run-codebuild-card", "card.json", 3)
          shared_test.runCodeBuild("run-codebuild-products", "products.json", 1)
          shared_test.runCodeBuild("run-codebuild-zap", "zap.json", 1)
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          putStep(
            "endtoend-ecr-registry-test",
            "endtoend-candidate-ecr-registry-test/image.tar",
            "parse-candidate-tag/release-tag",
            true
          )
          putStep(
            "endtoend-dockerhub",
            "endtoend-candidate-ecr-registry-test/image.tar",
            "",
            true
          )
        }
      }
    }
    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "pay-endtoend failed post-merge e2e tests"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "pay-endtoend passed post-merge e2e tests and was pushed as a final release" }
    )
  }

  new {
    name = "build-and-push-reverse-proxy-candidate"
    plan {
      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_test.getPayCi
          shared_test.getStep("reverse-proxy-git-release", true, false)
        }
      }

      parseReleaseTag("reverse-proxy-git-release")

      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_test.loadVar("release-number", "tags/release-number")
          shared_test.loadVar("release-name", "reverse-proxy-git-release/.git/ref")
          shared_test.loadVar("release-sha", "tags/release-sha")
          shared_test.loadVar("candidate-image-tag", "tags/candidate-tag")
          shared_test.loadVar("date", "tags/date")
          shared_test.assumeCodeBuildRole("builder", "codebuild-assume-role")
        }
      }

      shared_test.loadAssumeRoleVar
      shared_resources.generateDockerCredsConfigStep
      ...shared_resources_for_multi_arch_builds.multiArchCandidateBuild("reverse-proxy")
    }
    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "Failed to build and push e2e helper reverse-proxy"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "Built and pushed e2e helper reverse-proxy" }
    )
  }

  new {
    name = "reverse-proxy-e2e"
    plan {
      new InParallelStep {
        in_parallel = new Listing {
          shared_test.getStep("reverse-proxy-candidate-ecr-registry-test", true, true)
          shared_test.getPayCi
        }
      }

      parseCandidateTag("reverse-proxy-candidate-ecr-registry-test")
      shared_test.loadVar("candidate_number_tag", "parse-candidate-tag/release-number")
      shared_test.assumeCodeBuildRole("executor", "e2e-test-assume-role")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.loadVar("candidate_image_tag", "reverse-proxy-candidate-ecr-registry-test/tag")
          shared_test.loadAssumeRoleVar
        }
      }

      shared_test.prepareCodeBuild("reverse-proxy", "prepare-e2e-codebuild.yml", "((.:candidate_image_tag))")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.runCodeBuild("run-codebuild-card", "card.json", 3)
          shared_test.runCodeBuild("run-codebuild-products", "products.json", 1)
          shared_test.runCodeBuild("run-codebuild-zap", "zap.json", 1)
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          shared_resources.generateDockerCredsConfigStep
          parseCandidateTag("reverse-proxy-candidate-ecr-registry-test")
          shared_test.assumeCodeBuildRole("executor", "e2e-test-assume-role")
          assumeRetagRole
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.loadVarJson("retag-role", "assume-retag-role/assume-role.json")
          shared_test.loadVar("release_image_tag", "parse-candidate-tag/release-tag")
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          retagCandidateInEcr("reverse-proxy", "((.:release_image_tag))", "release")
          retagCandidateInEcr("reverse-proxy", "latest", "latest")
          retagCandidateInDockerHub(
            "governmentdigitalservice/pay-reverse-proxy",
            "((.:candidate_image_tag))",
            "release"
          )
        }
      }
    }
    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "e2e helper reverse-proxy failed post-merge e2e tests"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "e2e helper reverse-proxy passed post-merge e2e tests and was pushed as a final release" }
    )
  }

  new {
    name = "build-and-push-stubs-candidate"
    plan {
      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_test.getStep("stubs-git-release", true, false)
          shared_test.getPayCi
        }
      }

      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_resources.generateDockerCredsConfigStep
          shared_test.assumeCodeBuildRole("builder", "codebuild-assume-role")
        }
      }

      parseReleaseTag("stubs-git-release")

      new InParallelStep {
        in_parallel = new Listing<Step> {
          shared_test.loadVar("release-number", "tags/release-number")
          shared_test.loadVar("release-name", "stubs-git-release/.git/ref")
          shared_test.loadVar("release-sha", "tags/release-sha")
          shared_test.loadVar("date", "tags/date")
          shared_test.loadAssumeRoleVar
        }
      }

      ...shared_resources_for_multi_arch_builds.multiArchCandidateBuild("stubs")
    }

    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "Failed to build and push pay-stubs candidate image"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "Built and pushed pay-stubs candidate image" }
    )
  }

  new {
    name = "stubs-e2e"
    plan {
      new InParallelStep {
        in_parallel = new Listing {
          shared_test.getStep("stubs-candidate-ecr-registry-test", true, true)
          shared_test.getPayCi
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          shared_resources.generateDockerCredsConfigStep
          parseCandidateTag("stubs-candidate-ecr-registry-test")
          shared_test.assumeCodeBuildRole("executor", "e2e-test-assume-role")
          assumeRetagRole
          assumeWriteToDeployRole
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.loadVar("candidate_image_tag", "stubs-candidate-ecr-registry-test/tag")
          shared_test.loadAssumeRoleVar
          shared_test.loadVarJson("retag-role", "assume-retag-role/assume-role.json")
          shared_test.loadVarJson("write-to-deploy-role", "assume-write-to-deploy-role/assume-role.json")
          shared_test.loadVar("release_image_tag", "parse-candidate-tag/release-tag")
          shared_test.loadVar("release_number", "parse-candidate-tag/release-number")
        }
      }

      shared_test.prepareCodeBuild("stubs", "prepare-e2e-codebuild.yml", "((.:candidate_image_tag))")

      new InParallelStep {
        in_parallel = new Listing {
          shared_test.runCodeBuild("run-codebuild-card", "card.json", 3)
          shared_test.runCodeBuild("run-codebuild-products", "products.json", 1)
        }
      }

      new InParallelStep {
        in_parallel = new Listing {
          retagCandidateInEcr("stubs", "((.:release_image_tag))", "release")
          retagCandidateInEcr("stubs", "latest", "latest")
          retagCandidateInDockerHub(
            "governmentdigitalservice/pay-stubs",
            "((.:candidate_image_tag))",
            "release"
          )
          copyMultiarchImageToAccount("stubs")
        }
      }
    }
    on_failure = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { message = "pay-stubs failed post-merge e2e tests"
        slack_channel_for_failure = "#govuk-pay-starling" }
    )
    on_success = shared_resources_for_slack_notifications.paySlackNotification(
      new SlackNotificationConfig { is_a_success = true; message = "pay-stubs passed post-merge e2e tests and was pushed as a final release" }
    )
  }

  copyImageToEcr("postgres-15-alpine", "postgres:15-alpine")
  copyImageToEcr("localstack-localstack-3", "localstack/localstack:2.0")
  copyImageToEcr("selenium-standalone-chrome-3-141-59", "selenium/standalone-chrome:3-141-59")
}

// THINGS BELOW HERE MAY BE USEFUL IN SHARED_RESOURCES

local function buildImage(taskName: String, context: String): TaskStep = new {
  task = taskName
  privileged = true
  params {
    ["CONTEXT"] = context
    ["DOCKER_CONFIG"] = "docker_creds"
  }
  config {
    platform = "linux"
    image_resource {
      type = "registry-image"
      source { ["repository"] = "concourse/oci-build-task" }
    }
    inputs = new Listing {
      new TaskConfig.Input { name = context }
      new TaskConfig.Input { name = "docker_creds" }
    }
    outputs = new Listing {
      new TaskConfig.Output { name = "image" }
    }
    run { path = "build" }
  }
}

local function putCandidateImage(putName: String): PutStep =
  putStep(putName, "image/image.tar", "tags/candidate-tag", true)

local assumeRetagRole: TaskStep = new {
  task = "assume-retag-role"
  file = "pay-ci/ci/tasks/assume-role.yml"
  output_mapping = new {
    ["assume-role"] = "assume-retag-role"
  }
  params = new {
    ["AWS_ROLE_ARN"] = "arn:aws:iam::((pay_aws_test_account_id)):role/concourse"
    ["AWS_ROLE_SESSION_NAME"] = "retag-ecr-image-as-release"
  }
}

local assumeWriteToDeployRole: TaskStep = new {
  task = "assume-write-to-deploy-role"
  file = "pay-ci/ci/tasks/assume-role.yml"
  output_mapping = new {
    ["assume-role"] = "assume-write-to-deploy-role"
  }
  params = new {
    ["AWS_ROLE_ARN"] = "arn:aws:iam::((pay_aws_deploy_account_id)):role/concourse_dev_worker_ecr_access"
    ["AWS_ROLE_SESSION_NAME"] = "write-ecr-to-deploy"
  }
}

local function retagCandidateInDockerHub(repo: String, tag: String, taskTag: String): TaskStep = new {
  task = "retag-candidate-as-\(taskTag)-in-dockerhub"
  file = "pay-ci/ci/tasks/manifest-retag.yml"
  params = new {
    ["SOURCE_MANIFEST"] = "\(repo):\(tag)"
    ["NEW_MANIFEST"] = "\(repo):latest-master"
  }
}

local function retagCandidateInEcr(repo: String, tag: String, taskTag: String): TaskStep = new {
  task = "retag-candidate-as-\(taskTag)-in-ecr"
  file = "pay-ci/ci/tasks/manifest-retag.yml"
  params = new {
    ["DOCKER_LOGIN_ECR"] = "1"
    ["AWS_ACCOUNT_ID"] = "((pay_aws_test_account_id))"
    ["SOURCE_MANIFEST"] = "((pay_aws_test_account_id)).dkr.ecr.eu-west-1.amazonaws.com/govukpay/\(repo):((.:candidate_image_tag))"
    ["NEW_MANIFEST"] = "((pay_aws_test_account_id)).dkr.ecr.eu-west-1.amazonaws.com/govukpay/\(repo):\(tag)"
    ["AWS_ACCESS_KEY_ID"] = "((.:retag-role.AWS_ACCESS_KEY_ID))"
    ["AWS_SECRET_ACCESS_KEY"] = "((.:retag-role.AWS_SECRET_ACCESS_KEY))"
    ["AWS_SESSION_TOKEN"] = "((.:retag-role.AWS_SESSION_TOKEN))"
  }
}

local function copyMultiarchImageToAccount(repo: String): TaskStep = new {
  task = "copy-images-to-\(repo)-ecr-registry-deploy"
  file = "pay-ci/ci/tasks/copy-multiarch-image-to-other-account.yml"
  privileged = true
  params = new {
    ["DESTINATION_AWS_ACCESS_KEY_ID"] = "((.:write-to-deploy-role.AWS_ACCESS_KEY_ID))"
    ["DESTINATION_AWS_SECRET_ACCESS_KEY"] = "((.:write-to-deploy-role.AWS_SECRET_ACCESS_KEY))"
    ["DESTINATION_AWS_SESSION_TOKEN"] = "((.:write-to-deploy-role.AWS_SESSION_TOKEN))"
    ["DESTINATION_ECR_REGISTRY"] = "((pay_aws_deploy_account_id)).dkr.ecr.eu-west-1.amazonaws.com"
    ["ECR_REPO_NAME"] = "govukpay/\(repo)"
    ["RELEASE_NUMBER"] = "((.:release_number))"
    ["SOURCE_AWS_ACCESS_KEY_ID"] = "((.:retag-role.AWS_ACCESS_KEY_ID))"
    ["SOURCE_AWS_SECRET_ACCESS_KEY"] = "((.:retag-role.AWS_SECRET_ACCESS_KEY))"
    ["SOURCE_AWS_SESSION_TOKEN"] = "((.:retag-role.AWS_SESSION_TOKEN))"
    ["SOURCE_ECR_REGISTRY"] = "((pay_aws_test_account_id)).dkr.ecr.eu-west-1.amazonaws.com"
  }
}

local function copyImageToEcr(image: String, displayName: String): Job = new {
  name = "copy-\(image)"
  plan {
    shared_test.getStep(image, true, true)
    putStep("ecr-\(image)", "\(image)/image.tar", "", true)
  }
  on_failure = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { message = "Failed copying \(displayName) image from Docker Hub to ECR"
      slack_channel_for_failure = "#govuk-pay-starling" }
  )
  on_success = shared_resources_for_slack_notifications.paySlackNotification(
    new SlackNotificationConfig { is_a_success = true; message = "Copied \(displayName) image from Docker Hub to ECR" }
  )
}

local function parseReleaseTag(gitRelease: String): TaskStep = new {
  task = "parse-release-tag"
  file = "pay-ci/ci/tasks/parse-release-tag.yml"
  input_mapping {
    ["git-release"] = gitRelease
  }
}

local function parseCandidateTag(ecrRepo: String): TaskStep = new {
  task = "parse-candidate-tag"
  file = "pay-ci/ci/tasks/parse-candidate-tag.yml"
  input_mapping {
    ["ecr-repo"] = ecrRepo
  }
}

local function prepareCodeBuildMultiarch(project: String): TaskStep = new {
  task = "prepare-codebuild"
  file = "pay-ci/ci/tasks/prepare-codebuild-multiarch.yml"
  params = new {
    ["PROJECT_TO_BUILD"] = project
    ["AWS_ACCESS_KEY_ID"] = "((.:role.AWS_ACCESS_KEY_ID))"
    ["AWS_SECRET_ACCESS_KEY"] = "((.:role.AWS_SECRET_ACCESS_KEY))"
    ["AWS_SESSION_TOKEN"] = "((.:role.AWS_SESSION_TOKEN))"
    ["RELEASE_NUMBER"] = "((.:release-number))"
    ["RELEASE_NAME"] = "((.:release-name))"
    ["RELEASE_SHA"] = "((.:release-sha))"
    ["BUILD_DATE"] = "((.:date))"
  }
}

local function runCodeBuildMultiarch(project: String, attempts: Int): InParallelStep = new {
  in_parallel = new Listing {
    shared_test.runCodeBuild("run-codebuild-\(project)-amd64", "\(project)-amd64.json", attempts)
    shared_test.runCodeBuild("run-codebuild-\(project)-armv8", "\(project)-armv8.json", attempts)
  }
}

local function withTagRegex(tag: String) = new Mixin {
  source { ["tag_regex"] = tag }
}

local function withTag(tag: String) = new Mixin {
  source { ["tag"] = tag }
}

local function withCheckInterval(interval: String) = new Mixin {
  check_every = interval
}

local function putStep(resourceName: String, imageName: String, additionalTags: String, skipDownload: Boolean): PutStep = new PutStep {
  put = resourceName
  params {
    when (imageName.length > 0) {
      ["image"] = imageName
    }
    when (additionalTags.length > 0) {
      ["additional_tags"] = additionalTags
    }
  }
  get_params {
    when (skipDownload) {
      ["skip_download"] = true
    }
  }
}
